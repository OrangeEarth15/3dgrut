// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ========== çƒè°è¾å°„ç²’å­æ¨¡å‹ - 3DGSä¸­çš„é«˜çº§å…‰ç…§è®¡ç®—æ ¸å¿ƒ ==========
//
// ã€æ¨¡å—ä½œç”¨ã€‘ï¼š
// çƒè°è¾å°„ç²’å­æ¨¡å‹(Spherical Harmonic Radiative Particle Model)æ˜¯3Dé«˜æ–¯æº…å°„(3DGS)
// ä¸­ç”¨äºå®ç°å¤æ‚å…‰ç…§æ•ˆæœçš„æ ¸å¿ƒç»„ä»¶ã€‚å®ƒå°†ä¼ ç»Ÿçš„RGBé¢œè‰²æ‰©å±•ä¸ºæ–¹å‘æ€§å…‰ç…§è¡¨ç¤ºã€‚
//
// ã€æŠ€æœ¯åŸç†ã€‘ï¼š
// - ä½¿ç”¨çƒè°å‡½æ•°ç¼–ç æ–¹å‘æ€§å…‰ç…§ä¿¡æ¯ï¼ˆæ›¿ä»£ç®€å•çš„RGBå€¼ï¼‰
// - æ¯ä¸ªé«˜æ–¯ç²’å­å­˜å‚¨ä¸€ç»„çƒè°ç³»æ•°ï¼Œè€Œä¸æ˜¯å›ºå®šçš„é¢œè‰²
// - æ ¹æ®è§‚å¯Ÿæ–¹å‘åŠ¨æ€è®¡ç®—é¢œè‰²ï¼Œå®ç°è§†è§’ç›¸å…³çš„å…‰ç…§æ•ˆæœ
// - æ”¯æŒå¤æ‚çš„å…‰ç…§ç°è±¡ï¼šé•œé¢åå°„ã€æ¬¡è¡¨é¢æ•£å°„ã€å„å‘å¼‚æ€§æè´¨ç­‰
//
// ã€ä¸ä¼ ç»Ÿ3DGSçš„åŒºåˆ«ã€‘ï¼š
// ä¼ ç»Ÿ3DGSï¼šæ¯ä¸ªç²’å­ â†’ å›ºå®šRGBé¢œè‰²
// çƒè°3DGSï¼šæ¯ä¸ªç²’å­ â†’ çƒè°ç³»æ•°æ•°ç»„ â†’ åŸºäºè§‚å¯Ÿæ–¹å‘è®¡ç®—é¢œè‰²
//
// ã€è®¡ç®—æµç¨‹ã€‘ï¼š
// 1. å­˜å‚¨ï¼šæ¯ä¸ªç²’å­å­˜å‚¨RadianceMaxNumSphCoefficientsä¸ªçƒè°ç³»æ•°
// 2. æŸ¥è¯¢ï¼šæ ¹æ®å…¥å°„å…‰çº¿æ–¹å‘è®¡ç®—è¯¥æ–¹å‘çš„è¾å°„äº®åº¦
// 3. ç§¯åˆ†ï¼šåœ¨ä½“ç§¯æ¸²æŸ“ä¸­ç´¯ç§¯å¤šä¸ªç²’å­çš„è´¡çŒ®
// 4. è®­ç»ƒï¼šé€šè¿‡è‡ªåŠ¨å¾®åˆ†ä¼˜åŒ–çƒè°ç³»æ•°å‚æ•°
//
// ã€æ€§èƒ½ä¼˜åŠ¿ã€‘ï¼š
// - ç´§å‡‘è¡¨ç¤ºï¼š16ä¸ªç³»æ•°å¯è¡¨ç¤ºå¤æ‚çš„æ–¹å‘æ€§å…‰ç…§ï¼ˆvs æ¯æ–¹å‘ä¸€ä¸ªRGBï¼‰
// - è¿ç»­æ’å€¼ï¼šçƒè°åŸºå‡½æ•°ä¿è¯å…‰ç…§çš„å¹³æ»‘å˜åŒ–
// - GPUå‹å¥½ï¼šæ‰€æœ‰è®¡ç®—éƒ½æ˜¯ç®€å•çš„å¤šé¡¹å¼è¿ç®—
//
// ã€åº”ç”¨åœºæ™¯ã€‘ï¼š
// - é«˜è´¨é‡çš„ç¥ç»æ¸²æŸ“å’Œæ–°è§†è§’åˆæˆ
// - å¤æ‚æè´¨çš„å®æ—¶æ¸²æŸ“ï¼ˆé‡‘å±ã€ç»ç’ƒã€çš®è‚¤ç­‰ï¼‰
// - ç¯å¢ƒå…‰ç…§çš„é«˜æ•ˆè¿‘ä¼¼
// - å…‰ç…§æ„ŸçŸ¥çš„åœºæ™¯é‡å»º

/**
 * çƒè°è¾å°„ç²’å­æ¨¡å‹ (Spherical Harmonic Radiative Particle Model)
 * 
 * æœ¬æ¨¡å—å®ç°äº†åŸºäºçƒè°å‡½æ•°çš„è¾å°„ç²’å­ç³»ç»Ÿï¼Œç”¨äºé«˜æ•ˆè¡¨ç¤ºå’Œè®¡ç®—
 * å„å‘å¼‚æ€§çš„å…‰ç…§æ•ˆæœã€‚çƒè°å‡½æ•°æä¾›äº†ä¸€ç§ç´§å‡‘çš„æ–¹å¼æ¥ç¼–ç 
 * å¤æ‚çš„æ–¹å‘æ€§å…‰ç…§ä¿¡æ¯ã€‚
 * 
 * ä¸»è¦åŠŸèƒ½ï¼š
 * - çƒè°ç³»æ•°çš„å­˜å‚¨å’Œç®¡ç†
 * - çƒè°åŸºå‡½æ•°çš„ç¼–ç /è§£ç 
 * - æ”¯æŒè‡ªåŠ¨å¾®åˆ†çš„å‰å‘å’Œåå‘ä¼ æ’­
 * - ä½“ç§¯æ¸²æŸ“çš„ç§¯åˆ†è®¡ç®—
 */

// å¯¼å…¥çƒè°å‡½æ•°æ¨¡å—
#include <3dgut/kernels/slang/common/sphericalHarmonics.slang>

namespace shRadiativeParticle
{

/**
 * çƒè°è¾å°„å‚æ•°ç¼“å†²åŒºç®¡ç†ç»“æ„
 * 
 * ç®¡ç†çƒè°ç³»æ•°æ•°æ®çš„å­˜å‚¨å’Œæ¢¯åº¦æ›´æ–°ï¼Œæ”¯æŒä¸¤ç§æ¢¯åº¦æ›´æ–°æ¨¡å¼ï¼š
 * 1. æ’ä»–æ€§æ¨¡å¼ï¼šå•çº¿ç¨‹æˆ–æ— ç«äº‰ç¯å¢ƒä¸‹çš„ç›´æ¥æ›´æ–°
 * 2. å¹¶å‘æ¨¡å¼ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä½¿ç”¨åŸå­æ“ä½œçš„å®‰å…¨æ›´æ–°
 */
struct ParametersBuffer
{
    const vector<float, Dim>* _dataPtr;     // çƒè°ç³»æ•°æ•°æ®æŒ‡é’ˆï¼ˆåªè¯»ï¼‰
    vector<float, Dim> *_gradPtr;           // çƒè°ç³»æ•°æ¢¯åº¦æŒ‡é’ˆï¼ˆå¯å†™ï¼‰
    bool exclusiveGradient;                 // æ˜¯å¦ä½¿ç”¨æ’ä»–æ€§æ¢¯åº¦æ›´æ–°ï¼ˆé¿å…åŸå­æ“ä½œï¼‰
};

/**
 * çƒè°è¾å°„ç²’å­çš„é€šç”¨å‚æ•°
 * 
 * åŒ…å«æ¸²æŸ“å’Œè®¡ç®—æ‰€éœ€çš„å…¨å±€é…ç½®å‚æ•°
 */
struct CommonParameters
{
    ParametersBuffer parametersBuffer;      // å‚æ•°ç¼“å†²åŒºç®¡ç†å™¨
    int sphDegree;                         // çƒè°å‡½æ•°é˜¶æ•°ï¼ˆå†³å®šè¡¨ç¤ºç²¾åº¦ï¼‰
};

/**
 * çƒè°è¾å°„å‚æ•°ç»“æ„ - å­˜å‚¨æ‰€æœ‰çƒè°ç³»æ•°
 * 
 * å®ç°IDifferentiableæ¥å£ï¼Œæ”¯æŒè‡ªåŠ¨å¾®åˆ†ã€‚
 * çƒè°ç³»æ•°æ•°ç»„ç”¨äºå­˜å‚¨æ–¹å‘æ€§è¾å°„ä¿¡æ¯ï¼Œç³»æ•°æ•°é‡ç”±æœ€å¤§æ”¯æŒçš„çƒè°é˜¶æ•°å†³å®šã€‚
 * 
 * Dim: æ¯ä¸ªç³»æ•°çš„ç»´åº¦ï¼ˆé€šå¸¸ä¸º3ï¼Œå¯¹åº”RGBä¸‰é€šé“ï¼‰
 * RadianceMaxNumSphCoefficients: æœ€å¤§çƒè°ç³»æ•°æ•°é‡
 */
struct Parameters : IDifferentiable
{
    vector<float, Dim> sphCoefficients[RadianceMaxNumSphCoefficients];  // çƒè°ç³»æ•°æ•°ç»„
};

/**
 * ä»ç¼“å†²åŒºè·å–çƒè°å‚æ•°çš„å‰å‘å‡½æ•°
 * 
 * æ ¹æ®ç²’å­ç´¢å¼•ä»å…¨å±€ç¼“å†²åŒºä¸­æå–å¯¹åº”çš„çƒè°ç³»æ•°ã€‚
 * æ”¯æŒè‡ªåŠ¨å¾®åˆ†ï¼Œå¯åœ¨åå‘ä¼ æ’­ä¸­è®¡ç®—æ¢¯åº¦ã€‚
 * 
 * @param particleIdx ç²’å­ç´¢å¼•ï¼ˆä¸å‚ä¸å¾®åˆ†ï¼‰
 * @param parametersBuffer å‚æ•°ç¼“å†²åŒºï¼ˆä¸å‚ä¸å¾®åˆ†ï¼‰
 * @return åŒ…å«æ‰€æœ‰çƒè°ç³»æ•°çš„Parametersç»“æ„ä½“
 */
[BackwardDifferentiable][ForceInline]
Parameters fetchParametersFromBuffer(no_diff uint32_t particleIdx,
                                     no_diff ParametersBuffer parametersBuffer) 
{
    Parameters parameters;
    // è®¡ç®—ç²’å­åœ¨ç¼“å†²åŒºä¸­çš„åç§»ä½ç½®
    const uint32_t particleOffset = particleIdx * RadianceMaxNumSphCoefficients;
    
    // å¾ªç¯å±•å¼€ä¼˜åŒ–ï¼šé€ä¸ªå¤åˆ¶çƒè°ç³»æ•°
    [unroll] for (int i = 0; i < RadianceMaxNumSphCoefficients; ++i) {
        parameters.sphCoefficients[i] = parametersBuffer._dataPtr[particleOffset + i];
    }
    return parameters;
}

/**
 * çƒè°å‚æ•°è·å–å‡½æ•°çš„åå‘ä¼ æ’­ç‰ˆæœ¬
 * 
 * å®ç°fetchParametersFromBufferå‡½æ•°çš„æ¢¯åº¦åå‘ä¼ æ’­ã€‚
 * å°†è®¡ç®—å¾—åˆ°çš„æ¢¯åº¦ç´¯åŠ åˆ°å…¨å±€æ¢¯åº¦ç¼“å†²åŒºä¸­ã€‚
 * 
 * @param particleIdx ç²’å­ç´¢å¼•
 * @param parametersBuffer å‚æ•°ç¼“å†²åŒº
 * @param parametersGrad ä»åç»­è®¡ç®—ä¼ å›çš„æ¢¯åº¦
 */
[BackwardDerivativeOf(fetchParametersFromBuffer)][ForceInline] 
void fetchParametersFromBufferBwd(no_diff uint32_t particleIdx,
                                  no_diff ParametersBuffer parametersBuffer,
                                  Parameters parametersGrad) 
{
    const uint32_t particleOffset = particleIdx * RadianceMaxNumSphCoefficients;
    
    // å°†æ¢¯åº¦å†™å›åˆ°å…¨å±€ç¼“å†²åŒº
    [unroll] for (int i = 0; i < RadianceMaxNumSphCoefficients; ++i) {
        const vector<float, Dim> coeffs = parametersGrad.sphCoefficients[i];
        
        if (parametersBuffer.exclusiveGradient) {
            // æ’ä»–æ€§æ¨¡å¼ï¼šç›´æ¥ç´¯åŠ æ¢¯åº¦ï¼ˆæ€§èƒ½æ›´å¥½ï¼Œä½†éœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨ï¼‰
            [unroll] for (int j = 0; j < Dim; ++j) {
                parametersBuffer._gradPtr[particleOffset + i][j] += coeffs[j];
            }
        } else {
            // å¹¶å‘æ¨¡å¼ï¼šä½¿ç”¨åŸå­æ“ä½œç´¯åŠ æ¢¯åº¦ï¼ˆçº¿ç¨‹å®‰å…¨ï¼Œä½†æ€§èƒ½ç•¥ä½ï¼‰
            [unroll] for (int j = 0; j < Dim; ++j) {
                InterlockedAdd(parametersBuffer._gradPtr[particleOffset + i][j], coeffs[j]);
            }
        }
    }
}

/**
 * ä»ç¼“å†²åŒºè®¡ç®—çƒè°è¾å°„äº®åº¦
 * 
 * æ ¹æ®å…¥å°„å…‰çº¿æ–¹å‘å’Œçƒè°ç³»æ•°ï¼Œè®¡ç®—ç²’å­åœ¨è¯¥æ–¹å‘ä¸Šçš„è¾å°„äº®åº¦ã€‚
 * ä½¿ç”¨çƒè°åŸºå‡½æ•°è§£ç è·å¾—æœ€ç»ˆçš„é¢œè‰²å€¼ã€‚
 * 
 * @param particleIdx ç²’å­ç´¢å¼•
 * @param incidentDirection å…¥å°„å…‰çº¿æ–¹å‘ï¼ˆå•ä½å‘é‡ï¼‰
 * @param sphDegree çƒè°å‡½æ•°é˜¶æ•°
 * @param parametersBuffer å‚æ•°ç¼“å†²åŒº
 * @return å¯¹åº”æ–¹å‘çš„è¾å°„äº®åº¦å€¼
 */
[BackwardDifferentiable] [ForceInline]
vector<float, Dim> radianceFromBuffer(no_diff uint32_t particleIdx,
                                      no_diff float3 incidentDirection,
                                      no_diff uint32_t sphDegree,
                                      no_diff ParametersBuffer parametersBuffer)
{
    // ä½¿ç”¨çƒè°åŸºå‡½æ•°è§£ç ç³»æ•°ä¸ºè¾å°„äº®åº¦
    return sphericalHarmonics.decode<Dim, RadianceMaxNumSphCoefficients>(
               sphDegree,
               fetchParametersFromBuffer(particleIdx, parametersBuffer).sphCoefficients,
               incidentDirection);
}

// ========== integrateRadianceè°ƒç”¨é“¾ - ç¬¬4å±‚ï¼šæ ¸å¿ƒå®ç°ç®—æ³• ==========
//
// ğŸ¨ ã€è°ƒç”¨é“¾ç»ˆç‚¹ã€‘ï¼š
// 1. K-Buffer (gutKBufferRenderer.cuh:264) â†’ particles.featureIntegrateFwd()
// 2. C++åŒ…è£… (shRadiativeGaussianParticles.cuh:661) â†’ particleFeaturesIntegrateFwd()
// 3. Slangå¯¼å‡º (shRadiativeParticles.slang:299) â†’ shRadiativeParticle.integrateRadiance<false>()
// 4. ã€å½“å‰å±‚ã€‘æ ¸å¿ƒå®ç° (shRadiativeParticles.slang:205) â†’ é¢œè‰²æ··åˆç®—æ³•
//
// ã€æœ¬å±‚ä½œç”¨ã€‘ï¼šçƒè°è¾å°„ç²’å­çš„é¢œè‰²æ··åˆæ•°å­¦å®ç°
// - è¿™æ˜¯é¢œè‰²è°ƒç”¨é“¾çš„æœ€åº•å±‚ï¼Œå®ç°çœŸæ­£çš„é¢œè‰²æ··åˆç®—æ³•
// - æ”¯æŒä¸¤ç§æ··åˆæ¨¡å¼ï¼šç›´æ¥ç´¯ç§¯å’Œçº¿æ€§æ’å€¼
// - é€‚é…ä¸åŒçš„æ¸²æŸ“ç®—æ³•ï¼šK-Bufferã€æ’åºé€æ˜ã€Overæ··åˆ
// - é€šè¿‡æ¨¡æ¿å‚æ•°åœ¨ç¼–è¯‘æ—¶ä¼˜åŒ–æ€§èƒ½
//
// ğŸŒŒ ã€çƒè°å…‰ç…§èƒŒæ™¯ã€‘ï¼š
// - ä¼ ç»Ÿ3DGSï¼šæ¯ä¸ªç²’å­ â†’ å›ºå®šRGBé¢œè‰²
// - çƒè°3DGSï¼šæ¯ä¸ªç²’å­ â†’ çƒè°ç³»æ•°æ•°ç»„ â†’ åŸºäºè§‚å¯Ÿæ–¹å‘è®¡ç®—é¢œè‰²
// - è®¡ç®—æµç¨‹ï¼šå­˜å‚¨ç³»æ•° â†’ çƒè°åŸºå‡½æ•°è§£ç  â†’ æŒ‰æƒé‡æ··åˆ
// - ä¼˜åŠ¿ï¼šç´§å‡‘è¡¨ç¤ºã€è¿ç»­æ’å€¼ã€è§†è§’ç›¸å…³å…‰ç…§æ•ˆæœ
//
// ğŸ¨ ã€æ•°å­¦åŸç†ã€‘ï¼š
// é¢œè‰²æ··åˆå…¬å¼ï¼ˆä¸Alphaæ··åˆå¯¹åº”ï¼‰ï¼š
// å‰å‘åæ¨¡å¼ï¼šintegratedColor += particleColor Ã— weight
// åå‘å‰æ¨¡å¼ï¼šintegratedColor = lerp(oldColor, particleColor, weight)
// å…¶ä¸­ weight = alpha Ã— transmittance (ç”±densityIntegrateHitè®¡ç®—)
//
// ğŸ“Š ã€æ€§èƒ½ä¼˜åŒ–ã€‘ï¼š
// - [BackwardDifferentiable] æ”¯æŒè‡ªåŠ¨å¾®åˆ†ï¼Œç”¨äºç¥ç»ç½‘ç»œè®­ç»ƒ
// - [ForceInline] å¼ºåˆ¶å†…è”å±•å¼€ï¼Œå‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€
// - æ¨¡æ¿ç‰¹åŒ– <let backToFront : bool> ç¼–è¯‘æ—¶åˆ†æ”¯æ¶ˆé™¤
// - weight > 0.0f æ—©æœŸé€€å‡ºä¼˜åŒ–ï¼Œé¿å…æ— æ•ˆè®¡ç®—
//
/**
 * ç§¯åˆ†è¾å°„äº®åº¦ï¼ˆä½“ç§¯æ¸²æŸ“æ··åˆï¼‰- æ ¸å¿ƒå®ç°ç®—æ³•
 * 
 * ã€æ ¸å¿ƒåŠŸèƒ½ã€‘ï¼š
 * è¿™æ˜¯3DGUTç³»ç»Ÿä¸­é¢œè‰²æ··åˆçš„æ•°å­¦æ ¸å¿ƒï¼Œå®ç°ä½“ç§¯æ¸²æŸ“ä¸­çš„è¾å°„äº®åº¦ç§¯åˆ†ã€‚
 * æ”¯æŒä¸¤ç§æ··åˆæ¨¡å¼ï¼Œé€šè¿‡æ¨¡æ¿å‚æ•°åœ¨ç¼–è¯‘æ—¶ä¼˜åŒ–ï¼š
 * 1. å‰å‘åæ¨¡å¼ï¼šç›´æ¥ç´¯åŠ æƒé‡å€¼ (K-Bufferä½¿ç”¨)
 * 2. åå‘å‰æ¨¡å¼ï¼šä½¿ç”¨çº¿æ€§æ’å€¼æ··åˆï¼ˆé€‚ç”¨äºé¢„ç§¯åˆ†çš„alphaæ··åˆï¼‰
 * 
 * è¿™ä¸ªå‡½æ•°å¤„ç†ï¼š
 * - çƒè°è¾å°„ç‰¹å¾çš„æ•°å€¼ç§¯åˆ†
 * - å¤šå±‚é€æ˜ç²’å­çš„é¢œè‰²åˆæˆ
 * - è§†è§’ç›¸å…³å…‰ç…§æ•ˆæœçš„ç´¯ç§¯
 * 
 * @param weight æ··åˆæƒé‡ï¼ˆç”±densityIntegrateHitè®¡ç®—ï¼šalpha Ã— transmittanceï¼‰
 * @param radiance å½“å‰ç²’å­çš„è¾å°„äº®åº¦å‘é‡ï¼ˆRGBæˆ–çƒè°è§£ç ç»“æœï¼‰
 * @param integratedRadiance ç´¯ç§¯çš„è¾å°„äº®åº¦ï¼ˆè¾“å…¥è¾“å‡ºå‚æ•°ï¼Œæœ€ç»ˆåƒç´ é¢œè‰²ï¼‰
 */
[BackwardDifferentiable][ForceInline]
void integrateRadiance<let backToFront : bool>(float weight,
                                               in vector<float, Dim> radiance,
                                               inout vector<float, Dim> integratedRadiance)
{
    // ========== æ­¥éª¤1ï¼šæ—©æœŸé€€å‡ºä¼˜åŒ– ==========
    // å…³é”®ï¼šåªæœ‰æœ‰æ•ˆæƒé‡çš„ç²’å­æ‰è¿›è¡Œé¢œè‰²æ··åˆ
    // é¿å…æ— æ•ˆè®¡ç®—ï¼Œæé«˜GPUæ‰§è¡Œæ•ˆç‡
    if (weight > 0.0f)
    {
        // ========== æ­¥éª¤2ï¼šæ ¹æ®æ¸²æŸ“æ¨¡å¼é€‰æ‹©æ··åˆç®—æ³• ==========
        if (backToFront)
        {
            // åå‘å‰æ¨¡å¼ï¼šçº¿æ€§æ’å€¼æ··åˆï¼ˆOverç®—å­ï¼‰
            // å…¬å¼ï¼šresult = lerp(old, new, weight) = old * (1-weight) + new * weight
            // é€‚ç”¨äºï¼šæ·±åº¦æ’åºæ¸²æŸ“ã€Alphaæ··åˆç­‰
            integratedRadiance = lerp(integratedRadiance, radiance, weight);
        }
        else
        {
            // å‰å‘åæ¨¡å¼ï¼šç›´æ¥ç´¯åŠ ï¼ˆæ­£å‘ç©¿è¶Šï¼‰
            // å…¬å¼ï¼šresult += radiance * weight (åŠ æƒå¹³å‡)
            // é€‚ç”¨äºï¼šK-Bufferã€ä½“ç§¯æ¸²æŸ“ç­‰
            // å…³é”®ï¼šè¿™æ˜¯3DGUTä¸­K-Bufferä½¿ç”¨çš„ä¸»è¦æ¨¡å¼
            integratedRadiance += radiance * weight;
        }
    }
    // æ³¨æ„ï¼šå‡½æ•°ä¸ºvoidç±»å‹ï¼Œç›´æ¥ä¿®æ”¹integratedRadianceå‚æ•°
}

[BackwardDifferentiable][ForceInline]
void integrateRadianceFromParameters<let backToFront : bool>(float3 incidentDirection,
                                                             no_diff uint32_t sphDegree,
                                                             float weight,
                                                             Parameters parameters,
                                                             inout vector<float, Dim> integratedRadiance) 
{
    if (weight > 0.0f) 
    {
        integrateRadiance<backToFront>(
            weight,
            sphericalHarmonics.decode<Dim, RadianceMaxNumSphCoefficients>(
                sphDegree,
                parameters.sphCoefficients,
                incidentDirection),
            integratedRadiance
        );
    }
}

[BackwardDifferentiable][ForceInline]
void integrateRadianceFromBuffer<let backToFront : bool>(no_diff float3 incidentDirection,
                                                         no_diff uint32_t sphDegree,
                                                         float weight,
                                                         no_diff uint32_t particleIdx,
                                                         no_diff ParametersBuffer parametersBuffer,
                                                         inout vector<float, Dim> integratedRadiance)
{
    integrateRadianceFromParameters<backToFront>(incidentDirection,
                                                 sphDegree,
                                                 weight,
                                                 fetchParametersFromBuffer(particleIdx, parametersBuffer),
                                                 integratedRadiance);
}

} // namespace shRadiativeParticle

// ------------------------------------------------------------------------------------------------------------------
// å¯¼å‡ºå‡½æ•°å…¥å£ç‚¹ (CUDA Device Export Functions)
//
// ä»¥ä¸‹å‡½æ•°æ˜¯ä¸ºCUDAè®¾å¤‡ç«¯å¯¼å‡ºçš„å…¥å£ç‚¹ï¼Œå¯ä»¥è¢«C++/CUDAä»£ç è°ƒç”¨ã€‚
// è¿™äº›å‡½æ•°å°è£…äº†æ ¸å¿ƒçš„çƒè°è¾å°„è®¡ç®—åŠŸèƒ½ï¼Œæä¾›ç»Ÿä¸€çš„æ¥å£ã€‚

/**
 * ä»ç¼“å†²åŒºè·å–ç²’å­ç‰¹å¾ï¼ˆè¾å°„äº®åº¦ï¼‰
 * 
 * CUDAè®¾å¤‡ç«¯å¯¼å‡ºå‡½æ•°ï¼Œç”¨äºè·å–æŒ‡å®šç²’å­åœ¨ç‰¹å®šå…¥å°„æ–¹å‘ä¸Šçš„è¾å°„ç‰¹å¾ã€‚
 * 
 * @param particleIdx ç²’å­ç´¢å¼•
 * @param commonParameters é€šç”¨å‚æ•°ï¼ˆåŒ…å«ç¼“å†²åŒºå’Œçƒè°é˜¶æ•°ï¼‰
 * @param incidentDirection å…¥å°„å…‰çº¿æ–¹å‘
 * @return è¾å°„äº®åº¦ç‰¹å¾å‘é‡
 */
[CudaDeviceExport]
inline vector<float, shRadiativeParticle.Dim> particleFeaturesFromBuffer(in uint32_t particleIdx,
                                         shRadiativeParticle.CommonParameters commonParameters,
                                         in float3 incidentDirection)
{
    return sphericalHarmonics.decode<shRadiativeParticle.Dim, shRadiativeParticle.RadianceMaxNumSphCoefficients>(
        commonParameters.sphDegree,
        shRadiativeParticle.fetchParametersFromBuffer(particleIdx, commonParameters.parametersBuffer).sphCoefficients,
        incidentDirection);
}

// ========== particleFeaturesIntegrateFwdè°ƒç”¨é“¾ - ç¬¬3å±‚ï¼šSlangå¯¼å‡ºæ¥å£ ==========
//
// ğŸ¨ ã€è°ƒç”¨é“¾ä½ç½®ã€‘ï¼š
// 1. K-Buffer (gutKBufferRenderer.cuh:264) â†’ particles.featureIntegrateFwd()
// 2. C++åŒ…è£… (shRadiativeGaussianParticles.cuh:661) â†’ particleFeaturesIntegrateFwd()
// 3. ã€å½“å‰å±‚ã€‘Slangå¯¼å‡º (shRadiativeParticles.slang:299) â†’ shRadiativeParticle.integrateRadiance<false>()
// 4. æ ¸å¿ƒå®ç° (shRadiativeParticles.slang:205) â†’ é¢œè‰²æ··åˆç®—æ³•
//
// ã€æœ¬å±‚ä½œç”¨ã€‘ï¼šè¾å°„ç‰¹å¾ç§¯åˆ†çš„è·¨è¯­è¨€å¯¼å‡ºæ¥å£
// - [CudaDeviceExport] ä½¿å¾—Slangå‡½æ•°å¯ä»¥è¢«CUDA C++ä»£ç è°ƒç”¨
// - æä¾›ç¨³å®šçš„ABIè¾¹ç•Œï¼Œéš”ç¦»åº•å±‚çƒè°å…‰ç…§å®ç°ç»†èŠ‚
// - çº¯è½¬å‘å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨çƒè°è¾å°„ç²’å­çš„ç§¯åˆ†ç®—æ³•
// - ç¡®ä¿å‘é‡ç±»å‹å…¼å®¹æ€§å’Œå‚æ•°ä¼ é€’æ­£ç¡®æ€§
//
// ã€æ¸²æŸ“æ¨¡å¼ã€‘ï¼š
// - ä½¿ç”¨å‰å‘åéå†æ¨¡å¼ (backToFront=false)
// - ç›´æ¥ç´¯ç§¯æ¨¡å¼ï¼šintegratedFeatures += features * weight
// - é€‚ç”¨äºæ­£å‘ç©¿è¶Šçš„é¢œè‰²ç§¯åˆ† (front-to-back color integration)
//
// ğŸŒŒ ã€çƒè°å…‰ç…§åŸç†ã€‘ï¼š
// - shRadiativeParticle ä»£è¡¨æ”¯æŒçƒè°åŸºå‡½æ•°çš„è¾å°„ç²’å­
// - æ¯ä¸ªç²’å­å­˜å‚¨ä¸€ç»„çƒè°ç³»æ•°ï¼Œè€Œä¸æ˜¯å›ºå®šçš„RGBå€¼
// - æ ¹æ®è§‚å¯Ÿæ–¹å‘åŠ¨æ€è®¡ç®—é¢œè‰²ï¼Œå®ç°è§†è§’ç›¸å…³çš„å…‰ç…§æ•ˆæœ
// - æ”¯æŒå¤æ‚çš„å…‰ç…§ç°è±¡ï¼šé•œé¢åå°„ã€æ¬¡è¡¨é¢æ•£å°„ã€å„å‘å¼‚æ€§æè´¨
//
// ğŸ“Š ã€æ ¸å¿ƒå…¬å¼ã€‘ï¼ˆå°†åœ¨ç¬¬4å±‚å®ç°ï¼‰ï¼š
// if (weight > 0.0f) {
//     integratedFeatures += features * weight;  // ç›´æ¥ç´¯ç§¯æ¨¡å¼
// }
//
/**
 * ç²’å­ç‰¹å¾å‰å‘ç§¯åˆ† - Slangå¯¼å‡ºæ¥å£
 * 
 * åŠŸèƒ½ï¼šä¸ºCUDA C++ä»£ç æä¾›è°ƒç”¨Slangå®ç°çš„ç‰¹å¾ç§¯åˆ†åŠŸèƒ½çš„æ¥å£
 * ä½œç”¨ï¼šè¿™æ˜¯ä¸€ä¸ªçº¯è½¬å‘å‡½æ•°ï¼Œå°†è°ƒç”¨ç›´æ¥ä¼ é€’ç»™å†…éƒ¨çš„shRadiativeParticle.integrateRadiance()
 * 
 * å¯¹ç²’å­çš„è¾å°„ç‰¹å¾è¿›è¡Œå‰å‘ç§¯åˆ†ï¼ˆå‰å‘åéå†æ¨¡å¼ï¼‰ã€‚
 * ç”¨äºä½“ç§¯æ¸²æŸ“ä¸­çš„é¢œè‰²ç§¯åˆ†è®¡ç®—ã€‚
 * 
 * @param weight æ··åˆæƒé‡ï¼ˆç”±å‰é¢çš„densityIntegrateHitè®¡ç®—å¾—å‡ºï¼‰
 * @param features å½“å‰ç²’å­çš„è¾å°„ç‰¹å¾å‘é‡ï¼ˆRGBæˆ–çƒè°ç³»æ•°ï¼‰
 * @param integratedFeatures ç´¯ç§¯çš„è¾å°„ç‰¹å¾ï¼ˆè¾“å…¥è¾“å‡ºï¼Œä¼šè¢«ä¿®æ”¹ï¼‰
 */
[CudaDeviceExport]
inline void particleFeaturesIntegrateFwd(in float weight,
                                         in vector<float, shRadiativeParticle.Dim> features,
                                         inout vector<float, shRadiativeParticle.Dim> integratedFeatures)
{
    // ========== ç›´æ¥è½¬å‘åˆ°çƒè°è¾å°„ç²’å­çš„æ ¸å¿ƒç§¯åˆ†ç®—æ³• ==========
    // åŠŸèƒ½ï¼šå°†æ‰€æœ‰å‚æ•°ä¼ é€’ç»™çœŸæ­£çš„çƒè°è¾å°„ç§¯åˆ†å®ç°
    // æ¨¡æ¿å‚æ•°ï¼š<false> è¡¨ç¤ºä½¿ç”¨å‰å‘åæ¸²æŸ“æ¨¡å¼çš„ç›´æ¥ç´¯ç§¯
    // è¿”å›ç±»å‹ï¼švoidï¼Œç›´æ¥ä¿®æ”¹integratedFeatureså‚æ•°
    shRadiativeParticle.integrateRadiance<false>(
        weight,              // æ··åˆæƒé‡ï¼ˆalpha * transmittanceï¼‰
        features,            // å½“å‰ç²’å­çš„è¾å°„ç‰¹å¾
        integratedFeatures   // ç´¯ç§¯çš„è¾å°„ç‰¹å¾ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
    );
}

/**
 * ç›´æ¥ä»ç¼“å†²åŒºè¿›è¡Œç²’å­ç‰¹å¾å‰å‘ç§¯åˆ†
 * 
 * ç»„åˆäº†å‚æ•°è·å–å’Œç‰¹å¾ç§¯åˆ†çš„æ“ä½œï¼Œæé«˜æ•ˆç‡ã€‚
 * é€‚ç”¨äºæ¸²æŸ“å¾ªç¯ä¸­çš„ç›´æ¥è°ƒç”¨ã€‚
 * 
 * @param incidentDirection å…¥å°„å…‰çº¿æ–¹å‘
 * @param weight æ··åˆæƒé‡
 * @param particleIdx ç²’å­ç´¢å¼•
 * @param commonParameters é€šç”¨å‚æ•°
 * @param integratedFeatures ç´¯ç§¯çš„è¾å°„ç‰¹å¾ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 */
[CudaDeviceExport] inline void particleFeaturesIntegrateFwdFromBuffer(in float3 incidentDirection,
                                                   in float weight,
                                                   in uint32_t particleIdx,
                                                   shRadiativeParticle.CommonParameters commonParameters,
                                                   inout vector<float, shRadiativeParticle.Dim> integratedFeatures)
{
    shRadiativeParticle.integrateRadianceFromBuffer<false>(
        incidentDirection,
        commonParameters.sphDegree,
        weight,
        particleIdx,
        commonParameters.parametersBuffer,
        integratedFeatures);
}

/**
 * ç²’å­ç‰¹å¾åå‘ç§¯åˆ†ï¼ˆæ¢…åº¦è®¡ç®—ï¼‰
 * 
 * å®ç°ä½“ç§¯æ¸²æŸ“ç§¯åˆ†çš„åå‘ä¼ æ’­ï¼Œè®¡ç®—alphaå’Œç‰¹å¾çš„æ¢¯åº¦ã€‚
 * ä½¿ç”¨åå‘å‰æ¨¡å¼çš„æ··åˆå…¬å¼è¿›è¡Œåå‘é‡æ„ã€‚
 * 
 * @param alpha ä¸é€æ˜åº¦å€¼
 * @param alphaGrad alphaçš„æ¢¯åº¦ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 * @param features ç²’å­è¾å°„ç‰¹å¾
 * @param featuresGrad ç‰¹å¾æ¢¯åº¦ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 * @param integratedFeatures ç§¯åˆ†çš„ç‰¹å¾ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 * @param integratedFeaturesGrad ç§¯åˆ†ç‰¹å¾çš„æ¢¯åº¦ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 */
[CudaDeviceExport] void particleFeaturesIntegrateBwd(
    in float alpha,
    inout float alphaGrad,
    in vector<float, shRadiativeParticle.Dim> features,
    inout vector<float, shRadiativeParticle.Dim> featuresGrad,
    inout vector<float, shRadiativeParticle.Dim> integratedFeatures,
    inout vector<float, shRadiativeParticle.Dim> integratedFeaturesGrad)
{
    if(alpha > 0.0f)
    {
        // åˆ›å»ºå¾®åˆ†å¯¹ï¼ˆå€¼+æ¢¯åº¦ï¼‰
        DifferentialPair<float> alphaDiff = DifferentialPair<float>(alpha, alphaGrad);
        DifferentialPair<vector<float, shRadiativeParticle.Dim>> featuresDiff = 
            DifferentialPair<vector<float, shRadiativeParticle.Dim>>(features, featuresGrad);

        // åå‘å‰æ¨¡å¼çš„åå‘é‡æ„ï¼šä»ç§¯åˆ†ç»“æœæ¢å¤å‰ä¸€æ­¥çš„çŠ¶æ€
        const float weight = 1.0f / (1.0f - alpha);
        integratedFeatures = (integratedFeatures - features * alpha) * weight;
        DifferentialPair<vector<float, shRadiativeParticle.Dim>> integratedFeaturesDiff = 
            DifferentialPair<vector<float, shRadiativeParticle.Dim>>(integratedFeatures, integratedFeaturesGrad);

        // è°ƒç”¨åå‘å¾®åˆ†å‡½æ•°
        bwd_diff(shRadiativeParticle.integrateRadiance<true>)(
            alphaDiff,
            featuresDiff,
            integratedFeaturesDiff);

        // æå–æ¢¯åº¦ç»“æœ
        alphaGrad = alphaDiff.getDifferential();
        featuresGrad = featuresDiff.getDifferential();
        integratedFeaturesGrad = integratedFeaturesDiff.getDifferential();
    }
}

/**
 * ç›´æ¥å‘ç¼“å†²åŒºè¿›è¡Œç²’å­ç‰¹å¾åå‘ç§¯åˆ†
 * 
 * ç»„åˆäº†åå‘ç§¯åˆ†å’Œæ¢¯åº¦å›å†™çš„æ“ä½œï¼Œç›´æ¥å°†æ¢¯åº¦æ›´æ–°åˆ°å…¨å±€ç¼“å†²åŒºã€‚
 * é€‚ç”¨äºè®­ç»ƒé˜¶æ®µçš„æ¢¯åº¦ç§¯ç´¯ã€‚
 * 
 * @param incidentDirection å…¥å°„å…‰çº¿æ–¹å‘
 * @param alpha ä¸é€æ˜åº¦å€¼
 * @param alphaGrad alphaçš„æ¢¯åº¦ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 * @param particleIdx ç²’å­ç´¢å¼•
 * @param commonParameters é€šç”¨å‚æ•°
 * @param features ç²’å­è¾å°„ç‰¹å¾
 * @param integratedFeatures ç§¯åˆ†çš„ç‰¹å¾ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 * @param integratedFeaturesGrad ç§¯åˆ†ç‰¹å¾çš„æ¢¯åº¦ï¼ˆè¾“å…¥è¾“å‡ºï¼‰
 */
[CudaDeviceExport] void particleFeaturesIntegrateBwdToBuffer(
    in float3 incidentDirection,
    in float alpha,
    inout float alphaGrad,
    in uint32_t particleIdx,
    shRadiativeParticle.CommonParameters commonParameters,
    in vector<float, shRadiativeParticle.Dim> features,
    inout vector<float, shRadiativeParticle.Dim> integratedFeatures,
    inout vector<float, shRadiativeParticle.Dim> integratedFeaturesGrad) 
{
    if (alpha > 0.0f)
    {
        // åˆ›å»ºå¾®åˆ†å¯¹
        DifferentialPair<float> alphaDiff = DifferentialPair<float>(alpha, alphaGrad);
        
        // åå‘å‰æ¨¡å¼çš„åå‘é‡æ„
        const float weight = 1.0f / (1.0f - alpha);
        integratedFeatures = (integratedFeatures - features * alpha) * weight;
        DifferentialPair<vector<float, shRadiativeParticle.Dim>> integratedFeaturesDiff = 
            DifferentialPair<vector<float, shRadiativeParticle.Dim>>(integratedFeatures, integratedFeaturesGrad);

        // ç›´æ¥è°ƒç”¨å¸¦ç¼“å†²åŒºæ›´æ–°çš„åå‘å¾®åˆ†å‡½æ•°
        bwd_diff(shRadiativeParticle.integrateRadianceFromBuffer<true>)(
            incidentDirection,
            commonParameters.sphDegree,
            alphaDiff,
            particleIdx,
            commonParameters.parametersBuffer,
            integratedFeaturesDiff);

        // æå–æ¢¯åº¦ç»“æœ
        integratedFeaturesGrad = integratedFeaturesDiff.getDifferential();
        alphaGrad = alphaDiff.getDifferential();
    }
}

/**
 * å°†ç²’å­ç‰¹å¾æ¢¯åº¦åå‘ä¼ æ’­åˆ°ç¼“å†²åŒº
 * 
 * ç›´æ¥å°†ç‰¹å¾æ¢¯åº¦åå‘ä¼ æ’­åˆ°çƒè°ç³»æ•°ï¼Œæ›´æ–°å…¨å±€æ¢¯åº¦ç¼“å†²åŒºã€‚
 * é€‚ç”¨äºä¸éœ€è¦ä¸­é—´alphaæ¢¯åº¦çš„æƒ…å†µã€‚
 * 
 * @param particleIdx ç²’å­ç´¢å¼•
 * @param commonParameters é€šç”¨å‚æ•°
 * @param featuresGrad ç‰¹å¾æ¢¯åº¦
 * @param incidentDirection å…¥å°„å…‰çº¿æ–¹å‘
 */
[CudaDeviceExport] void particleFeaturesBwdToBuffer(
    in uint32_t particleIdx,
    shRadiativeParticle.CommonParameters commonParameters,
    in vector<float, shRadiativeParticle.Dim> featuresGrad,
    in float3 incidentDirection
)
{
    // ç›´æ¥è°ƒç”¨è¾å°„è®¡ç®—çš„åå‘å¾®åˆ†å‡½æ•°
    bwd_diff(shRadiativeParticle.radianceFromBuffer)(
        particleIdx,
        incidentDirection,
        commonParameters.sphDegree,
        commonParameters.parametersBuffer,
        featuresGrad);
}